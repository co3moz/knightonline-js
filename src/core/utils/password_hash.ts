import * as Long from 'long'

const encodingArray = [
  0x1a,
  0x1f, 0x11, 0x0a, 0x1e,
  0x10, 0x18, 0x02, 0x1d,
  0x08, 0x14, 0x0f, 0x1c,
  0x0b, 0x0d, 0x04, 0x13,
  0x17, 0x00, 0x0c, 0x0e,
  0x1b, 0x06, 0x12, 0x15,
  0x03, 0x09, 0x07, 0x16,
  0x01, 0x19, 0x05, 0x12,
  0x1d, 0x07, 0x19, 0x0f,
  0x1f, 0x16, 0x1b, 0x09,
  0x1a, 0x03, 0x0d, 0x13,
  0x0e, 0x14, 0x0b, 0x05,
  0x02, 0x17, 0x10, 0x0a,
  0x18, 0x1c, 0x11, 0x06,
  0x1e, 0x00, 0x15, 0x0c,
  0x08, 0x04, 0x01
];

const alphabetArray = [
  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
  0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
  0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a
];

export default function PasswordHash(password: string, encoding = 'utf8'): string {
  var buf = Array.from(Buffer.from(password, encoding));
  while (buf.length % 4 != 0) buf.push(0);

  var outBuf: number[] = [];
  var counter = 0, tmp = 0, inputKey = 0, outHash = 0;


  for (var i = 0; i < buf.length; i += 4) {
    let encoded = (buf[i] + (buf[i + 1] << 8) + (buf[i + 2] << 16) + (buf[i + 3] << 24)) >>> 0;
    tmp = (encoded + 0x03e8) >>> 0;
    inputKey = tmp;
    counter = 0;
    outHash = 0;

    do {
      tmp = inputKey;

      inputKey = inputKey >>> 1;
      if (tmp % 2 != 0) {
        tmp = encodingArray[counter / 4 >>> 0];
        outHash = (outHash + (((1 << (tmp | 0)) >>> 0))) >>> 0;
      }
      counter = (counter + 4) | 0;
    } while (inputKey > 0);

    var long = new Long(outHash);
    for (var j = 0; j < 7; j++) {
      var upper = long.mul(954437177).shiftRight(35);
      var anotherTmp = upper.mul(8).add(upper).shiftLeft(2).low >>> 0;
      var difference = (long.sub(anotherTmp.toString())).low >>> 0;
      outBuf.push(alphabetArray[difference]);
      long = upper;
    }
  }

  return Buffer.from(outBuf).toString('utf8');
}